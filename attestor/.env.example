# =============================================================================
# SERVER CONFIGURATION
# =============================================================================
# Override the default port for the attestor to run on (default: 8001)
PORT=
# Alternative port variable used by EigenCompute platform
# If set, this takes precedence over PORT
# APP_PORT=

# =============================================================================
# DATABASE CONFIGURATION (Supabase)
# =============================================================================
# Supabase project URL (from Project Settings > API)
SUPABASE_URL=
# Supabase service role key (for admin operations - keep secret!)
SUPABASE_SERVICE_KEY=
# Supabase anon key (for public read-only operations)
SUPABASE_ANON_KEY=
# JWT secret for admin session tokens (at least 32 characters, high entropy recommended)
JWT_SECRET=

# CORS allowed origins (comma-separated, use * for all origins)
# Example: https://console.lcore.io,https://app.locale.network
CORS_ALLOWED_ORIGINS=*
# =============================================================================
# OPERATOR WALLET CONFIGURATION
# =============================================================================
# You must set ONE of the following options:
#
# Option 1: Direct private key (traditional mode)
# ETH private key. This could be the private key of some other
# signature algorithm too. However, at the moment -- only ETH
# is supported.
PRIVATE_KEY=

# Option 2: Mnemonic phrase (EigenCompute TEE mode)
# When running on EigenCompute, the TEE provides a deterministic
# mnemonic through this environment variable. The wallet address
# is derived from this mnemonic and tied to the Docker image hash.
# MNEMONIC=
# Private & public key shares for this node's share
# of the threshold signature
TOPRF_SHARE_PRIVATE_KEY=
TOPRF_SHARE_PUBLIC_KEY=
# Overall public key for the threshold signature
TOPRF_PUBLIC_KEY=
# Private key for a $TOKEN-holding account
MECHAIN_PRIVATE_KEY=
# Addresses for prover contracts
TASK_CONTRACT_ADDRESS=
GOVERNANCE_CONTRACT_ADDRESS= 
# Provide a https proxy URL to allow for the creation of geo-specified
# tunnels. The attestor will replace {{geolocation}} in the URL
# with the geolocation it needs to connect to. geolocation is a 2-letter
# ISO code
HTTPS_PROXY_URL=
# Variables for the Elastic APM
ELASTIC_APM_SERVER_URL=
ELASTIC_APM_SECRET_TOKEN=
# Fraction of requests to be sampled & sent to the Elastic APM
ELASTIC_APM_SAMPLE_RATE=
# Set the log level for the attestor.
# Possible values are: debug, info, warn, error
LOG_LEVEL=
# Number of concurrent ZK proofs to generate
# Default is 10
ZK_CONCURRENCY=
# Chain ID for where the AVS operator is deployed. Only required for
# when registering the operator on the AVS.
# 11155111 = Sepolia (primary), 17000 = Holesky, 31337 = Local Anvil
CHAIN_ID=
# The publicly accessible URL for the attestor to be contacted on
# this URL will be used by customers to contact the attestor when they
# want to create a claim
# Example -- wss://attestor.example.com/ws
LOCALE_PUBLIC_URL=

# =============================================================================
# TEE WALLET REGISTRATION
# =============================================================================
# TEE wallet address (derived from MNEMONIC when running on EigenCompute)
# Required when running: npm run register:tee-wallet
TEE_WALLET_ADDRESS=

# Docker image hash for TEE attestation verification
# Generate with: docker build -f attestor.dockerfile -t attestor . && docker inspect --format='{{.Id}}' attestor | cut -d: -f2 | sed 's/^/0x/'
# Current hash: 0xd439a8593f9f439db49ea5787e24f1b10171fca0aff58d7f8fb258b59a438609
DOCKER_IMAGE_HASH=
# should the attestor pay the claim requests
# set to "1" to enable
ACCEPT_CLAIM_PAYMENT_REQUESTS=
# Disable checks for BGP announcement overlaps.
# Only recommended for testing purposes. Set to "1" to disable
# said checks.
DISABLE_BGP_CHECKS=
# If the attestor implements private authentication
# this is the public key that the attestor will use to
# verify the signature of the user attempting to connect.
#
# The public key will be of the same signature algorithm
# as the attestor's private key.
AUTHENTICATION_PUBLIC_KEY=

# =============================================================================
# L{CORE} CONFIGURATION (Privacy-Preserving Data Layer)
# =============================================================================
# Enable L{CORE} integration (1 = enabled, 0 = disabled)
LCORE_ENABLED=1

# L{CORE} Cartesi Node URL (for inspect queries)
# Production: http://34.28.51.59:10000
LCORE_NODE_URL=

# Blockchain RPC URL for submitting inputs
# Get from Alchemy/Infura/QuickNode
LCORE_RPC_URL=

# L{CORE} DApp contract address (deployed Cartesi application)
# Production: 0xAE0863401D5B953b89cad8a5E7c98f5136E9C26d
LCORE_DAPP_ADDRESS=

# Cartesi InputBox contract address (network-specific)
# Arbitrum Sepolia: 0x59b22D57D4f067708AB0c00552767405926dc768
LCORE_INPUTBOX_ADDRESS=

# Admin private key for decrypting L{CORE} responses
# This is a 32-byte NaCl private key, base64 encoded
# Generate with: node -e "const nacl=require('tweetnacl');const kp=nacl.box.keyPair();console.log('PRIVATE:',Buffer.from(kp.secretKey).toString('base64'));console.log('PUBLIC:',Buffer.from(kp.publicKey).toString('base64'))"
# IMPORTANT: Keep this secret! Only the TEE should have access.
LCORE_ADMIN_PRIVATE_KEY=

# Admin public key for encryption (optional - derived from private key)
LCORE_ADMIN_PUBLIC_KEY=

# =============================================================================
# CARTESI ROLLUP CONFIGURATION (for cartesi/ directory)
# =============================================================================
# Proof signing key for Cartesi rollup (REQUIRED)
# Generate with: node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
PROOF_SIGNING_KEY=

# Rollup HTTP server URL (set by Cartesi runtime in production)
# Default: http://127.0.0.1:5004
ROLLUP_HTTP_SERVER_URL=